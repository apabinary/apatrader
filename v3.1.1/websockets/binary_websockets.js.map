{"version":3,"sources":["../../../../src/websockets/binary_websockets.es6"],"names":["is_authenitcated_session","socket","get_app_id","app_ids","JSON","parse","config","local_storage","get","token","app_id","href","window","location","web_address","lastIndexOf","connect","i18n_name","value","api_url","websocket_url","ws","WebSocket","addEventListener","onopen","onclose","onmessage","event","growl","error","message","i18n","timeoutIsSet","require","tracker","trade_dialogs","get_trade_dialogs","fire_event","setTimeout","api","cached","authorize","then","reopen_trade_dialogs","chartingRequestMap","chart_registration_promises","Object","keys","forEach","key","req","symbol","timerHandler","promise","register","granularity","subscribe","count","style","catch","err","console","push","Promise","all","charts","chartOptions","getAllChartsWithTheirTypes","chart","refresh","id","chartType","callbacks","buffered_execs","buffered_sends","unresolved_promises","cached_promises","is_connected","readyState","length","data","shift","req_id","send","stringify","sent_before","reject","msg_type","cb","echo_req","resolve","needs_authentication","prop","balance","statement","profit_table","portfolio","proposal_open_contract","buy","sell","get_self_exclusion","set_self_exclusion","req_id_counter","send_request","authenticate","auth_successfull","val","set","is_jpy_account","landing_company_name","indexOf","ok","remove","up","code","invalidate","logout","close","i","send_authenticated_request","send_it","bind","oauth","name","args","fns","apply","undefined","timeout_promise","milliseconds","sell_expired_timeouts","proposal_op_store","proposal_open_contract_forget","events","on","off","index","splice","on_till","once_cb","done","contract_id","subscribers","stream_id","forget","proposal","forgetter","ex","execute","switch_account","inx","map","acc","account","unshift","forget_all","timeout","is_authenticated","sell_expired","epoch","now","Date","getTime","transaction"],"mappings":"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","file":"binary_websockets.js","sourcesContent":["/**\r\n * Created by arnab on 2/24/15.\r\n */\r\n\r\nimport $ from 'jquery';\r\nimport app_ids_json from 'text!../oauth/app_id.json';\r\nimport 'common/util';\r\n\r\nlet is_authenitcated_session = false; /* wether or not the current websocket session is authenticated */\r\nlet socket = null;\r\n\r\nconst get_app_id = () => {\r\n   const app_ids = JSON.parse(app_ids_json);\r\n   const config = local_storage.get('config');\r\n   let token = (config && config.app_id) || '';\r\n\r\n   if(!token) { /* find the appropriate token */\r\n      const href = window.location.href;\r\n      for(const web_address in app_ids) {\r\n         if(href.lastIndexOf(web_address, 0) == 0) {\r\n            token = app_ids[web_address];\r\n            break;\r\n         }\r\n      }\r\n   }\r\n   return token;\r\n}\r\n\r\nexport const app_id = get_app_id();\r\n\r\nconst connect = () => {\r\n   const config = local_storage.get('config');\r\n   const i18n_name = (local_storage.get('i18n') || { value: 'en' }).value;\r\n   const api_url = ((config && config.websocket_url)  || 'wss://ws.binaryws.com/websockets/v3?l='+i18n_name) + '&app_id=' + app_id;\r\n   const ws = new WebSocket(api_url);\r\n\r\n   ws.addEventListener('open', onopen);\r\n   ws.addEventListener('close', onclose);\r\n   ws.addEventListener('message', onmessage);\r\n\r\n   ws.addEventListener('error',(event) => {\r\n      $.growl.error({message: 'Connection error.'.i18n()});\r\n      onclose(); // try to reconnect\r\n   });\r\n\r\n   return ws;\r\n}\r\n\r\nlet timeoutIsSet = false;\r\nconst onclose = () => {\r\n   require(['windows/tracker'], (tracker) => {\r\n      const trade_dialogs = tracker.get_trade_dialogs();\r\n      is_authenitcated_session = false;\r\n      fire_event('logout');\r\n      /**\r\n       *  The connection is closed, resubscrible to tick streaming.\r\n       *  We have to make sure that resubscribe is atleast 1 second delayed\r\n       **/\r\n        if (timeoutIsSet) { return; }\r\n        timeoutIsSet = true;\r\n        setTimeout(() => {\r\n            timeoutIsSet = false;\r\n            socket = connect();\r\n            if(local_storage.get('oauth')) {\r\n              api.cached.authorize().then(\r\n                 () => tracker.reopen_trade_dialogs(trade_dialogs)\r\n              );\r\n            }\r\n            require(['charts/chartingRequestMap'], (chartingRequestMap) => {\r\n                const chart_registration_promises = [];\r\n               Object.keys(chartingRequestMap).forEach((key) => {\r\n                  const req = chartingRequestMap[key];\r\n                  if (req && req.symbol && !req.timerHandler) { /* resubscribe */\r\n                     const promise = chartingRequestMap.register({\r\n                        symbol: req.symbol,\r\n                        granularity: req.granularity,\r\n                        subscribe: 1,\r\n                        count: 1,\r\n                        style: req.granularity > 0 ? 'candles' : 'ticks'\r\n                     })\r\n                        .catch((err) => console.error(err));\r\n                     chart_registration_promises.push(promise);\r\n                  }\r\n               });\r\n\r\n               /* refresh the charts when they are reregistered.  */\r\n               Promise.all(chart_registration_promises)\r\n                  .then(() => {\r\n                     require(['charts/charts', 'charts/chartOptions'], (charts, chartOptions) => {\r\n                        chartOptions.getAllChartsWithTheirTypes().forEach(\r\n                           (chart) => charts.refresh('#' + chart.id + '_chart', null, chart.chartType)\r\n                        );\r\n                     });\r\n                  })\r\n            });\r\n        }, 1000);\r\n   });\r\n}\r\n\r\nconst callbacks = {};\r\nconst buffered_execs = [];\r\nconst buffered_sends = [];\r\nconst unresolved_promises = { /* req_id: { resolve: resolve, reject: reject, data: data } */};\r\nconst cached_promises = { /* key: {data: data, promise: promise } */}; /* requests that have been cached */\r\nconst is_connected = () => (socket && socket.readyState === 1);\r\n\r\n\r\nconst onopen = () => {\r\n   /* send buffered sends */\r\n   while (buffered_sends.length > 0) {\r\n      const data = buffered_sends.shift();\r\n      if(!unresolved_promises[data.req_id]) {\r\n         socket.send(JSON.stringify(data));\r\n      }\r\n   }\r\n   /* if the connection got closed while the result of an unresolved request\r\n           is not back yet, issue the same request again */\r\n   for(const key in unresolved_promises) {\r\n      const promise = unresolved_promises[key];\r\n      if(!promise) continue;\r\n      if(promise.sent_before) { /* reject if sent once before */\r\n         promise.reject({message: 'Connection closed.'.i18n()});\r\n      } else { /* send */\r\n         promise.sent_before = true;\r\n         socket.send(JSON.stringify(promise.data));\r\n      }\r\n   }\r\n   while (buffered_execs.length > 0)\r\n      buffered_execs.shift()();\r\n}\r\n\r\n/* execute buffered executes */\r\nconst onmessage = (message) => {\r\n   const data = JSON.parse(message.data);\r\n\r\n   /* do not block the main thread */\r\n   /* note: this will prevent subscribers from altering callbacks[data.msg_type] array\r\n           while we are iterating on it. this is especially important for tick trades */\r\n   (callbacks[data.msg_type] || []).forEach((cb) => {\r\n      setTimeout(\r\n         () => cb(data)\r\n         , 0);\r\n   });\r\n\r\n   const key = data.req_id;\r\n   const promise = unresolved_promises[key];\r\n   if (promise) {\r\n      delete unresolved_promises[key];\r\n      if (data.error) {\r\n         data.error.echo_req = data.echo_req;\r\n         data.error.req_id = data.req_id;\r\n         promise.reject(data.error);\r\n      }\r\n      else\r\n         promise.resolve(data);\r\n   }\r\n}\r\n\r\nsocket = connect(); // connect\r\n\r\n//This is triggering asycn loading of tick_handler.\r\n//The module will automatically start working as soon as its loaded\r\nrequire(['websockets/stream_handler']); // require tick_handler to handle ticks.\r\n\r\n/* whether the given request needs authentication or not */\r\nconst needs_authentication = (data) => {\r\n   for (const prop in\r\n      { balance: 1, statement: 1,\r\n         profit_table: 1, portfolio: 1,\r\n         proposal_open_contract: 1, buy: 1, sell: 1,\r\n         get_self_exclusion : 1, set_self_exclusion : 1 })\r\n      if (prop in data)\r\n      return true;\r\n   return false;\r\n};\r\n\r\n/* send a raw request and return a promise */\r\nlet req_id_counter = 0;\r\nconst send_request = (data) => {\r\n   data.req_id = ++req_id_counter;\r\n\r\n   return new Promise((resolve,reject) => {\r\n      unresolved_promises[data.req_id] = { resolve: resolve, reject: reject, data: data };\r\n      if (is_connected()) {\r\n         socket.send(JSON.stringify(data));\r\n      } else\r\n         buffered_sends.push(data);\r\n   });\r\n};\r\n\r\n/* authenticate and return a promise */\r\nconst authenticate = (token) => {\r\n   let auth_successfull = false;\r\n   const data = { authorize: token },\r\n      key = JSON.stringify(data),\r\n      promise = send_request(data);\r\n\r\n   return promise\r\n      .then((val) => {\r\n         is_authenitcated_session = true;\r\n         local_storage.set('authorize', val.authorize); /* we can use the 'email' field retruned later */\r\n         const is_jpy_account = val.authorize.landing_company_name.indexOf('japan') !== -1;\r\n         if(!is_jpy_account) {\r\n            fire_event('login', val);\r\n         }\r\n         if(local_storage.get('oauth-login')) {\r\n            const ok = local_storage.get('oauth-login').value;\r\n            local_storage.remove('oauth-login');\r\n            if(ok && !is_jpy_account) {\r\n               fire_event('oauth-login', val);\r\n            }\r\n         }\r\n         auth_successfull = true;\r\n         cached_promises[key] = { data: data, promise: promise }; /* cache successfull authentication */\r\n\r\n         return val; /* pass the result */\r\n      })\r\n      .catch((up) => {\r\n         if (up.code!==\"SelfExclusion\" && !auth_successfull) {    /* authentication request is failed, clear local_storage */\r\n            is_authenitcated_session = false;\r\n            fire_event('logout');\r\n            local_storage.remove('oauth');\r\n         }\r\n         delete cached_promises[key];\r\n         throw up; /* pass the exception to next catch */\r\n      });\r\n};\r\n\r\n/* un-athenticate current session */\r\nexport const invalidate = () => {\r\n   local_storage.remove('oauth');\r\n   local_storage.remove('authorize');\r\n   fire_event(\"reset_realitycheck\");\r\n\r\n   api.send({logout: 1}) /* try to logout and if it fails close the socket */\r\n      .catch((err) =>{\r\n         $.growl.error({ message: err.message });\r\n         socket.close();\r\n      });\r\n   /* remove authenticated cached requests as well as authorize requests */\r\n   for(const i in cached_promises)\r\n      if(needs_authentication(cached_promises[i].data) || ('authorize' in cached_promises[i].data))\r\n         delete cached_promises[i];\r\n}\r\n\r\n/* first authenticate and then send the request */\r\nconst send_authenticated_request = (data) => {\r\n   if (is_authenitcated_session)\r\n      return send_request(data);\r\n\r\n   const send_it = send_request.bind(null,data);\r\n\r\n   if(local_storage.get('oauth')) {\r\n      const oauth = local_storage.get('oauth');\r\n      let token = oauth[0].token;\r\n      return authenticate(token)\r\n         .then(send_it);\r\n   }\r\n   else\r\n      return Promise.reject({ message: 'Please log in'.i18n()});\r\n};\r\n\r\n/* fire a custom event and call registered callbacks(api.events.on(name)) */\r\nconst fire_event =(name , ...args) =>{\r\n   const fns = callbacks[name] || [];\r\n   fns.forEach((cb) => {\r\n      setTimeout(\r\n         () => cb.apply(undefined, args)\r\n         ,0);\r\n   });\r\n}\r\n\r\n/* the current websocket api (v3) does not return a result for closed markets,\r\n       use this a a temporary workaround to timeout 'ticks_history' api call while laoding charts,\r\n       TODO: wait for backend to fix this! */\r\nconst timeout_promise =(key, milliseconds) => {\r\n   setTimeout(() => {\r\n      const promise = unresolved_promises[key];\r\n      if (promise) {\r\n         delete unresolved_promises[key];\r\n         promise.reject({message: 'Timeout for websocket request'.i18n()});\r\n      }\r\n   },milliseconds);\r\n};\r\n\r\nconst sell_expired_timeouts = {};\r\nconst proposal_op_store =  {/* contract_id: { subscribers: n, promise: promise, stream_id: '' } */};\r\nconst proposal_open_contract_forget =  {/* contract_id:  promise */};\r\n\r\nexport const events = {\r\n   on: (name, cb) => {\r\n      (callbacks[name] = callbacks[name] || []).push(cb);\r\n      return cb;\r\n   },\r\n   off: (name, cb) =>{\r\n      if(callbacks[name]) {\r\n         const index = callbacks[name].indexOf(cb);\r\n         index !== -1 && callbacks[name].splice(index, 1);\r\n      }\r\n   },\r\n   /* callback function should return true to unsubscribe */\r\n   on_till:(name, cb) =>{\r\n      const once_cb = (...args) => {\r\n         const done = cb(...args);\r\n         if(done)\r\n            api.events.off(name,once_cb);\r\n      }\r\n      api.events.on(name, once_cb);\r\n   }\r\n}\r\n\r\nexport const proposal_open_contract = {\r\n   subscribe: (contract_id) => {\r\n      /* already subscribed */\r\n      if(proposal_op_store[contract_id] && proposal_op_store[contract_id].subscribers > 0) {\r\n         proposal_op_store[contract_id].subscribers++;\r\n         return proposal_op_store[contract_id].promise;\r\n      }\r\n      /* subscribe and keep the promise */\r\n      const promise = api.send({proposal_open_contract: 1, contract_id: contract_id, subscribe: 1})\r\n         .then((data) => {\r\n            /* keep stream_id to easily forget */\r\n            proposal_op_store[contract_id].stream_id = data.proposal_open_contract.id;\r\n            return data;\r\n         })\r\n         .catch((up) => {\r\n            proposal_op_store[contract_id] = undefined;\r\n            throw up;\r\n         });\r\n      proposal_op_store[contract_id] = { subscribers: 1, promise: promise };\r\n      return promise;\r\n   },\r\n   forget: (contract_id) => {\r\n      const proposal = proposal_op_store[contract_id];\r\n      const forget = proposal_open_contract_forget[contract_id];\r\n      if(!proposal) {\r\n         return forget || Promise.resolve(); /* contract is being forgetted or does not exit */\r\n      }\r\n      if(proposal.subscribers == 0) {\r\n         return forget; /* contract is being forgetted */\r\n      }\r\n      proposal.subscribers--;\r\n      if(proposal.subscribers > 0) { /* there are still subscribers to this contract_id */\r\n         return Promise.resolve();\r\n      }\r\n      const forgetter = () => {\r\n         proposal_op_store[contract_id] = undefined;\r\n         return api.send({forget: proposal.stream_id})\r\n            .catch((up) => {\r\n               proposal_open_contract_forget[contract_id] = undefined;\r\n               throw up;\r\n            })\r\n            .then((data) => {\r\n               proposal_open_contract_forget[contract_id] = undefined;\r\n               return data;\r\n            })\r\n      };\r\n      if(proposal.stream_id) {\r\n         proposal_open_contract_forget[contract_id] = forgetter();\r\n      } else {\r\n         proposal_open_contract_forget[contract_id] = proposal.promise\r\n            .catch((ex) => { return; })\r\n            .then((data) => {\r\n               if(proposal.stream_id) /* proposal request had not exceptions */\r\n                  return forgetter();\r\n               else return; /* no stream, no need to forget */\r\n            });\r\n      }\r\n      return proposal_open_contract_forget[contract_id];\r\n   }\r\n}\r\n\r\n/* execute callback when the connection is ready */\r\nexport const execute = (cb) => {\r\n   if (is_connected())\r\n      setTimeout(cb, 0);// always run the callback async\r\n   else\r\n      buffered_execs.push(cb);\r\n}\r\n\r\n/* switch account */\r\nexport const switch_account = (id) => {\r\n   const oauth = local_storage.get('oauth');\r\n   if(!oauth) {\r\n      return Promise.reject({ message: 'Account token not found.'.i18n() });\r\n   }\r\n\r\n   const inx = oauth.map((acc) => acc.id).indexOf(id);\r\n   if(inx === -1) {\r\n      return promise.reject({ message: 'Account id not found.'.i18n() });\r\n   }\r\n\r\n   /* move the new account to the front of oauth array */\r\n   const account = oauth[inx];\r\n   oauth.splice(inx,1);\r\n   oauth.unshift(account);\r\n   local_storage.set('oauth', oauth);\r\n\r\n   /* remove authenticated cached requests as well as authorize requests */\r\n   for(const i in cached_promises)\r\n      if(needs_authentication(cached_promises[i].data) || ('authorize' in cached_promises[i].data))\r\n         delete cached_promises[i];\r\n   /* back removes all tokens on {logout: 1} request, so we simply reauthenticate\r\n             with the new token without logging out first! ot switch accounts */\r\n   is_authenitcated_session = false;\r\n\r\n   /* backend doesn't respect registered authenticated streams :/ */\r\n   api.send({forget_all: 'transaction'})\r\n      .catch((err) => console.error(err));\r\n\r\n   api.send({forget_all: 'balance'})\r\n      .catch((err) => console.error(err));\r\n\r\n   return api.cached.authorize().then(\r\n      () => fire_event(\"switch_account\")\r\n   );\r\n}\r\n\r\n/* if you want a request to be cached, that is when multiple modules request\r\n*  the same data or a module request a data multiple times, instead of calling\r\n*  liveapi.send can liveapi.cached.send.\r\n*  node: this will only cache if the result was successfull */\r\nexport const cached  = {\r\n   send:(data) => {\r\n      const key = JSON.stringify(data);\r\n      /* if there is a cached promise for this key (let say P), return P.\r\n       * assume P is in pending state, when P is fullfiled all attached .then() calls will run.\r\n       * assume P is in rejected state (or in fullfiled state), the changed .then() calls will be immediately rejected(or fullfiled).  */\r\n                if (cached_promises[key])\r\n                    return cached_promises[key].promise;\r\n      /* We don't want to cache promises that are rejected,\r\n                   Clear the cache in case of promise rejection */\r\n      cached_promises[key] = { data: data, promise: null };\r\n      return cached_promises[key].promise = api.send(data)\r\n         .then(\r\n            (val) => val, /* on resolve: do nothing */\r\n            (up) => {\r\n               delete cached_promises[key]; throw up;\r\n            } /* on reject: clear cache */\r\n         );\r\n   },\r\n   /* return the promise from last successfull authentication request,\r\n               if the session is not already authorized will send an authentication request */\r\n   authorize: () => {\r\n      const oauth = local_storage.get('oauth');\r\n      const token = oauth && oauth[0] && oauth[0].token,\r\n         key = JSON.stringify({ authorize: token });\r\n\r\n      if (is_authenitcated_session && token && cached_promises[key])\r\n         return cached_promises[key].promise;\r\n\r\n      return token ? authenticate(token) : /* we have a token => autheticate */\r\n         Promise.reject('Please log in.'.i18n());\r\n   }\r\n}\r\n\r\n\r\n/* sends a request and returns an es6-promise */\r\nexport const send = (data, timeout) => {\r\n   if (data && needs_authentication(data))\r\n      return send_authenticated_request(data);\r\n\r\n   const promise = send_request(data);\r\n   if(timeout) timeout_promise(data.req_id, timeout); //NOTE: \"timeout\" is a temporary fix for backend, try not to use it.\r\n   return promise;\r\n}\r\n\r\n/* whether current session is authenticated or not */\r\nexport const is_authenticated = () => is_authenitcated_session;\r\n\r\n\r\nexport const sell_expired = (epoch) => {\r\n   const now = (new Date().getTime())/1000 | 0;\r\n   epoch = epoch || now+1; // if epoch is undefined will try to sell expired contract 3 seconds later.\r\n   if(!sell_expired_timeouts[epoch] && epoch*1 > now) {\r\n      sell_expired_timeouts[epoch] = setTimeout(() => {\r\n         sell_expired_timeouts[epoch] = undefined;\r\n         api.send({sell_expired:1}).catch((err) => console.error(err));\r\n      }, (epoch+2 - now)*1000);\r\n   }\r\n}\r\n\r\nconst api = {\r\n   events,\r\n   proposal_open_contract,\r\n   execute,\r\n   switch_account,\r\n   cached,\r\n   send,\r\n   is_authenticated,\r\n   sell_expired,\r\n   invalidate,\r\n   app_id\r\n}\r\n\r\n/* always register for transaction & balance streams */\r\napi.events.on('login',() => {\r\n   api.send({transaction: 1, subscribe:1})\r\n      .catch((err) => console.error(err));\r\n\r\n   api.send({balance: 1, subscribe:1})\r\n      .catch((err) => console.error(err));\r\n});\r\n/* always forget transaction & balance streams on logout */\r\napi.events.on('logout',() => {\r\n   api.send({forget_all: 'transaction'})\r\n      .catch((err) => console.error(err));\r\n\r\n   api.send({forget_all: 'balance'})\r\n      .catch((err) => console.error(err));\r\n});\r\n\r\n export default api;\r\n"]}